// fetch the files that xegos exist in
import { promises as fs } from "fs";
import fileEndings from "./file-endings";
import Xego from "./xego";

/*
This code is reading a text file and parsing the contents into xego commands.
- generated by stenography ðŸ¤–
*/
const readXegoTxtFile = async (path: string) => {
    if (!path.endsWith(".txt")) {
        throw new Error("Path must end with .txt");
    }
    const xegoFile = await fs.readFile(path, "utf8");
    let xegoCommand = ''
    let fileEnding = ''
    let xegos = xegoFile.split("\n")
    for (let i = 0; i < xegos.length; i++) {
        if (i === 0) {
            fileEnding = fileEndings[xegos[i].split(":")[1].trim().toLowerCase()]
        } else {
            const ll = await fs.readFile('xegos/' + xegos[i] + fileEnding, "utf8");
            xegoCommand += ll + "\n"
        }
    }
    // await fs.writeFile(path + 'xego-tower' + fileEnding, xegoCommand);
    return xegoCommand
}

const writeXegoToFile = async (xego: Xego): Promise<boolean> => { 
    try {
        /*
        creates a file with the name of the xego block and the file ending.
        uses xegoTower iff it exists.
        then writes out the contents of xego to a file in xegos/
        - generated by stenography ðŸ¤–
        */
        const editedCode = xego.xegoTower 
        ? xego.xegoTower + '\n\n' + xego.startComment + ' ' + xego.command + ' ' + xego.endComment + '\n\n' + xego.code 
        : xego.startComment + ' ' + xego.command + ' ' + xego.endComment + '\n\n' + xego.code;
        
        await fs.writeFile(xego.name ? 'xegos/' + xego.name + xego.fileEnding : 'xegos/' + xego.command.split(' ').join('-') + xego.fileEnding, editedCode, 'utf8');
        return true;
    } catch (err) {
        throw err;
    }
}

export {
    readXegoTxtFile,
    writeXegoToFile
}